<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-83">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue - methods vs computed</title>
  </head>
  <body>

<!--
[computed속성과 methods속성의 차이점]

    # methods속성
    - 호출할 때만 해당 로직이 수행.(수동적으로 데이터를 갱신)

    # computed속성
    - 대상 데이터의 값이 변경되면 자동적으로 수행.(능동적으로 데이터를 갱신)
    - computed속성에서 사용하고 있는  data속성 값의 변화에 따라 자동으로 다시 연산.

    ==> methods속성은 수행할 때마다 연산을 하기 때문에 별도로 캐싱을 하지 않지만,
        computed속성은 데이터가 변경되지 않는 한 이전의 계산 값을 가지고 있다가(캐싱하고 있다가) 필요할 때 바로 반환.
        따라서 복잡한 연산을 반복 수행해서 화면에 나타내야한다면
        computed속성을 이용하는 것이 methods속성을 이용하는 것보다 성능 면에서 효율적.
-->


    <div id="app">
      <p>{{ message }}</p>
      <p>{{ reversedMessage }}</p>
      <p>{{ reversedMessage }}</p>
      <p>{{ reversedMessage }}</p>
      <button v-on:click="reverseMsg">문자열 역순</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js"></script> <!--뷰 CDN-->
    <script>
      new Vue({
        el : '#app'
        ,data : {
          message : 'Hello Vue.js!'
        }
        ,computed : {
          reversedMessage : function(){
            return this.message.split('').reverse().join('');
          }
        }
        ,methods : {
          reverseMsg : function(){ //버튼을 클릭했을때만 메서드가 동작.
            this.message = this.message.split('').reverse().join('');
            return this.message;
          }
        }
      })
      </script>
  </body>
</html>
